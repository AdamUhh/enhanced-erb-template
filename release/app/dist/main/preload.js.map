{"version":3,"file":"preload.js","mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,SACb,GAAqB,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,OACP,CACJ,IAAIK,EAAIL,IACR,IAAI,IAAIM,KAAKD,GAAuB,iBAAZJ,QAAuBA,QAAUF,GAAMO,GAAKD,EAAEC,EACvE,CACA,CATD,CASGC,QAAQ,I,mBCRX,IAAIC,EAAsB,CCA1BA,EAAyBP,IACH,oBAAXQ,QAA0BA,OAAOC,aAC1CC,OAAOC,eAAeX,EAASQ,OAAOC,YAAa,CAAEG,MAAO,WAE7DF,OAAOC,eAAeX,EAAS,aAAc,CAAEY,OAAO,GAAO,G,YCL9D,MAAM,EAA+BC,QAAQ,YCQ7C,IAAYC,GAAZ,SAAYA,GACV,uBACA,6BACA,6BACA,oCACA,2BACA,2BACA,sCACA,oCAEA,2DAEA,sCACA,sCACA,kCAEA,kCACA,kCAEA,qDACD,CApBD,CAAYA,IAAAA,EAAW,KCLhB,MCAMC,EAAmCL,OAAOM,OAAOF,GACjDG,EAAqBF,EAAkBG,KDDpBC,GAAyB,GAAGA,YCE/CC,EAAgB,IAAIL,KAAsBE,GCchD,MAgDMI,EAAuB,CAClCC,EACAC,EAAc,WAEd,MAAMC,ECvED,SAAwBF,GAC7B,IAAIE,EAAmB,GAYvB,OATEA,EADmB,iBAAVF,EACEA,EACFA,GAAOG,UAAUC,KACfC,KAAKC,UAAUN,EAAMG,SAASC,MAChCJ,GAAOO,SAAWP,aAAiBQ,MACjCR,EAAMO,QAENF,KAAKC,UAAUN,GAGrBE,CACT,CDyDmBO,CAAeT,GAChC,MAAO,CACLU,SAAS,EACTT,MACAU,QAAST,GAAY,GACtB,EEvEGU,EAA6B,CACjCC,ICqF8B,CAC9BC,GApES,CACTjB,EACAkB,KAEIjB,EAAckB,SAASnB,IACzB,EAAAoB,YAAYH,GAAGjB,GAAS,CAACqB,KAAMC,IAASJ,EAASG,KAAMC,IAAM,EAgE/DC,eAxDqB,CACrBvB,EACAkB,KAEIjB,EAAckB,SAASnB,IACzB,EAAAoB,YAAYG,eAAevB,GAAS,CAACqB,KAAMC,IAASJ,EAASG,KAAMC,IAAM,EAoD3EE,mBA7C0BxB,IACtBC,EAAckB,SAASnB,IAAU,EAAAoB,YAAYI,mBAAmBxB,EAAQ,EA6C5EyB,KArCW,CACXzB,EACAc,KAEIb,EAAckB,SAASnB,IAAU,EAAAoB,YAAYK,KAAKzB,EAASc,EAAQ,EAkCvEY,OA1Ba,IACVJ,IAIH,IAAIK,SAAQ,CAACC,EAASC,KACpB,MAAO7B,EAASc,GAAWQ,EACvBrB,EAAckB,SAASnB,GACzB,EAAAoB,YACGM,OAAO1B,EAASc,GAChBgB,MAAMC,GACLH,EAAQG,KAETC,OAAO7B,GACN0B,EAAO3B,EAAqBC,EAAO,sBAGvC0B,EAAO3B,EAAqBF,EAAS,mB,aD9E3C,EAAAiC,cAAcC,kBAAkB,WAAYnB,G","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///webpack/runtime/make namespace object","webpack:///external node-commonjs \"electron\"","webpack:///./src/shared/types/ipc.ts","webpack:///./src/shared/utils/getReplyChannel.ts","webpack:///./src/shared/utils/channels.ts","webpack:///./src/main/listeners/util/ipcReplies.ts","webpack:///./src/main/utils/stringifyError.ts","webpack:///./src/main/preload.ts","webpack:///./src/main/bridges/ipcRenderer.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"electron\");","import { CoreElectronStore } from './coreElectronStore';\r\nimport { GenericFunction } from './generic';\r\n\r\nexport type SetStoreValuePayload = {\r\n  key: keyof CoreElectronStore;\r\n  state: CoreElectronStore[keyof CoreElectronStore];\r\n};\r\n\r\nexport enum IpcChannels {\r\n  closeApp = 'close-app',\r\n  minimizeApp = 'minimize-app',\r\n  maximizeApp = 'maximize-app',\r\n  isAppMaximized = 'is-app-maximized',\r\n  restartApp = 'restart-app',\r\n  clearStore = 'clear-store',\r\n  checkForUpdates = 'check-for-updates',\r\n  toggleDevTools = 'toggle-dev-tools',\r\n\r\n  toggleRendererErrorDialog = 'toggle-renderer-error-dialog',\r\n\r\n  exportStoreData = 'export-store-data',\r\n  importStoreData = 'import-store-data',\r\n  loadStoreData = 'load-store-data',\r\n\r\n  setStoreValue = 'set-store-value',\r\n  getStoreValue = 'get-store-value',\r\n\r\n  toggleExampleVisibility = 'toggle-example-visibility',\r\n}\r\n\r\n/** Typesafe: Expected payload INPUT for ipcChannels */\r\nexport type IpcExpectedPayloadLookup = {\r\n  [IpcChannels.setStoreValue]: SetStoreValuePayload;\r\n  [IpcChannels.getStoreValue]: keyof CoreElectronStore;\r\n  [IpcChannels.toggleExampleVisibility]: { showBye: boolean } | null;\r\n};\r\n\r\n/** Typesafe: Expected payload RETURN for ipcChannels */\r\nexport type IpcExpectedReturnLookup = {\r\n  [IpcChannels.isAppMaximized]: boolean;\r\n  [IpcChannels.getStoreValue]: CoreElectronStore[keyof CoreElectronStore];\r\n  [IpcChannels.toggleExampleVisibility]: boolean;\r\n};\r\n\r\n/** Typesafe: Special expected payload RETURN, specifically for ipcMain.handle ipcChannels\r\n *\r\n * This overrides return from IpcExpectedReturnLookup\r\n */\r\nexport type IpcExpectedMainHandleReturnLookup = {\r\n  [IpcChannels.setStoreValue]: CoreElectronStore[keyof CoreElectronStore];\r\n};\r\n\r\n/**\r\n * Represents the return type of an IPC (Inter-Process Communication) invoke operation.\r\n * @template P The type of the payload included in the response.\r\n */\r\nexport type IpcInvokeReturn<P = any> = {\r\n  success: boolean;\r\n  msg: string;\r\n  payload: P;\r\n};\r\n\r\n/**\r\n * Represents the error return type of an IPC invoke operation.\r\n */\r\nexport type IpcInvokeErrorReturn = {\r\n  success: false;\r\n  msg: string;\r\n  payload: string;\r\n};\r\n\r\n/**\r\n * Represents the expected payload type for a specific IPC channel.\r\n * @template T The type of the IPC channel.\r\n * @template P The type of the payload.\r\n */\r\nexport type IpcExpectedPayload<\r\n  T extends IpcChannels,\r\n  P = undefined,\r\n> = T extends keyof IpcExpectedReturnLookup ? IpcExpectedReturnLookup[T] : P;\r\n\r\n/**\r\n * Represents the expected payload type specifically for a main process IPC handle.\r\n * @template T The type of the IPC channel.\r\n * @template P The type of the payload.\r\n */\r\nexport type IpcExpectedMainHandlePayload<\r\n  T extends IpcChannels,\r\n  P = undefined,\r\n> = T extends keyof IpcExpectedMainHandleReturnLookup\r\n  ? IpcExpectedMainHandleReturnLookup[T]\r\n  : P;\r\n\r\n/**\r\n * Represents the expected payload return type for an IPC channel\r\n * with main process handle types having priority\r\n * @template T The type of the IPC channel.\r\n * @template P The type of the payload.\r\n */\r\nexport type IpcExpectedPayloadReturn<\r\n  T extends IpcChannels,\r\n  P = undefined,\r\n> = T extends keyof IpcExpectedMainHandleReturnLookup\r\n  ? IpcExpectedMainHandleReturnLookup[T]\r\n  : IpcExpectedPayload<T, P>;\r\n\r\n/**\r\n * Represents the return type for an IPC channel.\r\n * @template T The type of the IPC channel.\r\n */\r\nexport type IpcReturn<T extends IpcChannels> =\r\n  | IpcInvokeReturn<IpcExpectedPayloadReturn<T>>\r\n  | IpcInvokeErrorReturn;\r\n\r\n/**\r\n * Represents the conditional input type for an IPC channel.\r\n * @template T The type of the IPC channel.\r\n */\r\nexport type IpcInputConditional<T extends IpcChannels> =\r\n  T extends keyof IpcExpectedPayloadLookup\r\n    ? IpcExpectedPayloadLookup[T]\r\n    : undefined;\r\n\r\nexport interface I_IpcApi {\r\n  /**\r\n   * Attaches an event listener to the specified IPC channel.\r\n   * @param {string} channel - The IPC channel to listen on.\r\n   * @param {function} func - The function to be executed when the event occurs.\r\n   */\r\n  on(channel: string, callback: GenericFunction): void;\r\n  /**\r\n   * Removes an event listener from the specified IPC channel.\r\n   * @param {string} channel - The IPC channel to remove the listener from.\r\n   * @param {function} func - The function to be removed from the listeners.\r\n   */\r\n  removeListener(channel: string, callback: GenericFunction): void;\r\n  /**\r\n   * Removes all event listeners from the specified IPC channel.\r\n   * @param {string} channel - The IPC channel to remove the listener from.\r\n   */\r\n  removeAllListeners(channel: string): void;\r\n  /**\r\n   * Sends a message to the specified IPC channel.\r\n   * @param {string} channel - The IPC channel to send the message to.\r\n   * @param {any} payload - The data to be sent with the message.\r\n   */\r\n  send<T extends IpcChannels>(\r\n    ...args: T extends keyof IpcExpectedPayloadLookup\r\n      ? [channel: T, payload: IpcInputConditional<T>]\r\n      : [channel: T]\r\n  ): void;\r\n  /**\r\n   * Sends a message to the specified IPC channel and back to renderer\r\n   * @param {string} channel - The IPC channel to send the message to.\r\n   * @param {any} payload - The data to be sent with the message.\r\n   */\r\n  invoke<T extends IpcChannels>(\r\n    ...args: T extends keyof IpcExpectedPayloadLookup\r\n      ? [channel: T, payload: IpcInputConditional<T>]\r\n      : [channel: T]\r\n  ): Promise<IpcReturn<T>>;\r\n}\r\n","import { IpcChannels } from 'shared/types/ipc';\r\n\r\n/** Converts base channels to a `*-reply` channel */\r\nexport const getReplyChannel = (channel: IpcChannels) => `${channel}-reply`;\r\n","import { IpcChannels } from '../types/ipc';\r\nimport { getReplyChannel } from './getReplyChannel';\r\n\r\nexport const baseValidChannels: IpcChannels[] = Object.values(IpcChannels);\r\nexport const replyValidChannels = baseValidChannels.map(getReplyChannel);\r\nexport const validChannels = [...baseValidChannels, ...replyValidChannels];\r\n","import { IpcMainEvent } from 'electron';\r\nimport {\r\n  IpcChannels,\r\n  IpcInvokeErrorReturn,\r\n  IpcInvokeReturn,\r\n} from '../../../shared/types/ipc';\r\nimport { getReplyChannel } from '../../../shared/utils/getReplyChannel';\r\nimport { stringifyError } from '../../utils/stringifyError';\r\n\r\n/** Sends a success object to the same renderer frame that sent the original request\r\n *\r\n * Requires a `*-reply` channel that is listening\r\n *\r\n * Provided channel is automatically converted into a `*-reply` channel\r\n *\r\n * Used in ipcMain.on() listeners\r\n *\r\n * Useful if you want some component to run code after a success for a specific channel\r\n */\r\nexport const replySuccess = (\r\n  event: IpcMainEvent,\r\n  channel: IpcChannels,\r\n  payload?: { msg?: string; payload?: any },\r\n) => {\r\n  event.reply(getReplyChannel(channel), {\r\n    success: true,\r\n    msg: payload?.msg ?? '',\r\n    payload: payload?.payload ?? undefined,\r\n  } as IpcInvokeReturn);\r\n};\r\n\r\n/** Sends a failure object to the same renderer frame that sent the original request\r\n *\r\n * Requires a `*-reply` channel that is listening,\r\n *\r\n * Provided channel is automatically converted into a `*-reply` channel\r\n *\r\n * Used in ipcMain.on() listeners\r\n *\r\n * Useful if you want some component to run code after a failure for a specific channel\r\n *\r\n */\r\nexport const replyFailure = (\r\n  event: IpcMainEvent,\r\n  channel: IpcChannels,\r\n  payload?: { msg?: string; payload?: any },\r\n) => {\r\n  console.log(\r\n    `Oops, there was an error on channel: ${channel}${\r\n      payload?.msg && `\\n->Message:\\n${payload.msg}`\r\n    } ${payload?.payload && `\\n-> Payload:\\n ${payload.payload}`}\\n`,\r\n  );\r\n  event.reply(getReplyChannel(channel), {\r\n    success: false,\r\n    msg: payload?.msg ?? '',\r\n    payload: payload?.payload ?? undefined,\r\n  } as IpcInvokeErrorReturn);\r\n};\r\n\r\n/** Returns a failure object to the ipc that called the invoke\r\n *\r\n * Suited for ipcMain.handle() listeners\r\n *\r\n * @param error Stringified Error object (most likely from catch statement)\r\n * @param msg Custom error message\r\n * @returns Standard invoke return object; {success: boolean, msg: string, payload: string}\r\n */\r\nexport const returnIpcInvokeError = (\r\n  error: any,\r\n  msg: string = 'Error',\r\n): IpcInvokeErrorReturn => {\r\n  const errorStr = stringifyError(error);\r\n  return {\r\n    success: false,\r\n    msg,\r\n    payload: errorStr ?? '',\r\n  };\r\n};\r\n","export function stringifyError(error: any): string {\r\n  let errorStr: string = '';\r\n\r\n  if (typeof error === 'string') {\r\n    errorStr = error;\r\n  } else if (error?.response?.data) {\r\n    errorStr = JSON.stringify(error.response.data);\r\n  } else if (error?.message || error instanceof Error) {\r\n    errorStr = error.message;\r\n  } else {\r\n    errorStr = JSON.stringify(error);\r\n  }\r\n\r\n  return errorStr;\r\n}\r\n","import { contextBridge } from 'electron';\r\n\r\nimport { ipcApi } from './bridges/ipcRenderer';\r\nimport { I_ElectronApi } from '../shared/types/window';\r\n\r\nconst electronApi: I_ElectronApi = {\r\n  ipc: ipcApi,\r\n};\r\n\r\ncontextBridge.exposeInMainWorld('electron', electronApi);\r\n","/**\r\n *\r\n * This file contains the typesafe ipcRenderer logic that is used on client/renderer side to be sent to main\r\n *\r\n */\r\n\r\nimport { ipcRenderer, IpcRendererEvent } from 'electron';\r\nimport {\r\n  I_IpcApi,\r\n  IpcChannels,\r\n  IpcExpectedPayloadLookup,\r\n  IpcExpectedPayloadReturn,\r\n  IpcInputConditional,\r\n  IpcInvokeReturn,\r\n  IpcReturn,\r\n} from '../../shared/types/ipc';\r\nimport { validChannels } from '../../shared/utils/channels';\r\nimport { returnIpcInvokeError } from '../listeners/util/ipcReplies';\r\n\r\n/**\r\n * Attaches an event listener to the specified IPC channel.\r\n * @param channel - The IPC channel to listen on.\r\n * @param callback - The function to be executed when the event occurs.\r\n */\r\nconst on = (\r\n  channel: IpcChannels,\r\n  callback: (event: IpcRendererEvent, ...args: any[]) => void,\r\n): void => {\r\n  if (validChannels.includes(channel))\r\n    ipcRenderer.on(channel, (_, ...args) => callback(_, ...args));\r\n};\r\n\r\n/**\r\n * Removes an event listener from the specified IPC channel.\r\n * @param channel - The IPC channel to remove the listener from.\r\n * @param callback - The function to be removed from the listeners.\r\n */\r\nconst removeListener = (\r\n  channel: IpcChannels,\r\n  callback: (event: IpcRendererEvent, ...args: any[]) => void,\r\n): void => {\r\n  if (validChannels.includes(channel))\r\n    ipcRenderer.removeListener(channel, (_, ...args) => callback(_, ...args));\r\n};\r\n\r\n/**\r\n * Removes all event listeners from the specified IPC channel.\r\n * @param channel - The IPC channel to remove the listener from.\r\n */\r\nconst removeAllListeners = (channel: IpcChannels): void => {\r\n  if (validChannels.includes(channel)) ipcRenderer.removeAllListeners(channel);\r\n};\r\n\r\n/**\r\n * Typesafe IPC method that sends a `send` message to the specified IPC channel.\r\n * @param channel - The IPC channel to send the message to.\r\n * @param payload - The data to be sent with the message.\r\n */\r\nconst send = <T extends IpcChannels>(\r\n  channel: T,\r\n  payload?: IpcInputConditional<T>,\r\n): void => {\r\n  if (validChannels.includes(channel)) ipcRenderer.send(channel, payload);\r\n};\r\n\r\n/**\r\n * Typesafe IPC method that sends an `invoke` message to the specified IPC channel and returns a response back (to the renderer)\r\n * @param channel - The IPC channel to send the message to.\r\n * @param payload - The data to be sent with the message.\r\n */\r\nconst invoke = <T extends IpcChannels>(\r\n  ...args: T extends keyof IpcExpectedPayloadLookup\r\n    ? [channel: T, payload?: IpcInputConditional<T>]\r\n    : [channel: T]\r\n): Promise<IpcReturn<T>> =>\r\n  new Promise((resolve, reject) => {\r\n    const [channel, payload] = args;\r\n    if (validChannels.includes(channel)) {\r\n      ipcRenderer\r\n        .invoke(channel, payload)\r\n        .then((result: IpcInvokeReturn<IpcExpectedPayloadReturn<T>>) =>\r\n          resolve(result),\r\n        )\r\n        .catch((error: unknown) =>\r\n          reject(returnIpcInvokeError(error, 'Error in invoke')),\r\n        );\r\n    } else {\r\n      reject(returnIpcInvokeError(channel, 'Invalid Channel'));\r\n    }\r\n  });\r\n\r\nexport const ipcApi: I_IpcApi = {\r\n  on,\r\n  removeListener,\r\n  removeAllListeners,\r\n  send,\r\n  invoke,\r\n};\r\n"],"names":["root","factory","exports","module","define","amd","a","i","global","__webpack_require__","Symbol","toStringTag","Object","defineProperty","value","require","IpcChannels","baseValidChannels","values","replyValidChannels","map","channel","validChannels","returnIpcInvokeError","error","msg","errorStr","response","data","JSON","stringify","message","Error","stringifyError","success","payload","electronApi","ipc","on","callback","includes","ipcRenderer","_","args","removeListener","removeAllListeners","send","invoke","Promise","resolve","reject","then","result","catch","contextBridge","exposeInMainWorld"],"sourceRoot":""}