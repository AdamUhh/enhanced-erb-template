{"version":3,"file":"preload.js","mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,SACb,GAAqB,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,OACP,CACJ,IAAIK,EAAIL,IACR,IAAI,IAAIM,KAAKD,GAAuB,iBAAZJ,QAAuBA,QAAUF,GAAMO,GAAKD,EAAEC,EACvE,CACA,CATD,CASGC,QAAQ,I,mBCRX,IAAIC,EAAsB,CCA1BA,EAAyBP,IACH,oBAAXQ,QAA0BA,OAAOC,aAC1CC,OAAOC,eAAeX,EAASQ,OAAOC,YAAa,CAAEG,MAAO,WAE7DF,OAAOC,eAAeX,EAAS,aAAc,CAAEY,OAAO,GAAO,G,YCL9D,MAAM,EAA+BC,QAAQ,YCQ7C,IAAKC,ECRAC,GDQL,SAAKD,GACH,uBACA,6BACA,6BACA,2BACA,2BACA,sCACA,oCACA,sCACA,sCACA,kCACA,kCACA,iCACD,CAbD,CAAKA,IAAAA,EAAW,KCRhB,SAAKC,GACH,gCACA,kDACA,wDACA,6CACD,CALD,CAAKA,IAAAA,EAA0B,KAW5BA,EAA2BC,cAI3BD,EAA2BE,uBAI3BF,EAA2BG,0BAI3BH,EAA2BI,qBAhB9B,MCCMC,EAAmBC,GAAyB,GAAGA,UCH/CC,EAAmCZ,OAAOa,OAAOT,GAkBjDU,EAAqBF,EAAkBG,IAAIL,GAC3CM,EAAgB,IAAIJ,KAAsBE,GCnB1CG,EAA6B,CACjCC,IDqG8B,CAC9BC,GA7ES,CACTR,EACAS,KAEIJ,EAAcK,SAASV,IACzB,EAAAW,YAAYH,GAAGR,GAAS,CAACY,KAAMC,IAASJ,EAAKG,KAAMC,I,EAyErDC,eAhEqB,CACrBd,EACAS,KAEIJ,EAAcK,SAASV,IACzB,EAAAW,YAAYG,eAAed,GAAS,CAACY,KAAMC,IAASJ,EAAKG,KAAMC,I,EA4DjEE,mBApD0Bf,IACtBK,EAAcK,SAASV,IACzB,EAAAW,YAAYI,mBAAmBf,E,EAmDjCgB,KA1CW,CAAkBhB,KAAoBiB,KAC7CZ,EAAcK,SAASV,IACzB,EAAAW,YAAYK,KAAKhB,KAAYiB,E,EAyC/BC,OAhCa,CAIblB,EACAiB,IAEA,IAAIE,SAAQ,CAACC,EAASC,KAChBhB,EAAcK,SAASV,GACzB,EAAAW,YACGO,OAAOlB,EAASiB,GAChBK,MAAMC,GAA+BH,EAAQG,KAC7CC,OAAOC,GAGNJ,EAAO,CAAEK,SAAS,EAAOC,SAAU,QAASV,QAASQ,MAIzDJ,EAAO,CACLK,SAAS,EACTE,IAAK,kBACLX,QAASjB,G,aC7FjB,EAAA6B,cAAcC,kBAAkB,WAAYxB,G","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///webpack/runtime/make namespace object","webpack:///external node-commonjs \"electron\"","webpack:///./src/shared/types/ipc.ts","webpack:///./src/shared/types/keybindings.ts","webpack:///./src/shared/utils/ipc.ts","webpack:///./src/main/bridges/ipc.ts","webpack:///./src/main/preload.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"electron\");","import { GenericFunction } from './generic';\r\nimport { CoreElectronStore } from './coreElectronStore';\r\n\r\ntype SetStoreValuePayload = {\r\n  key: keyof CoreElectronStore;\r\n  state: CoreElectronStore[keyof CoreElectronStore];\r\n};\r\n\r\nenum IpcChannels {\r\n  closeApp = 'close-app',\r\n  minimizeApp = 'minimize-app',\r\n  maximizeApp = 'maximize-app',\r\n  restartApp = 'restart-app',\r\n  clearStore = 'clear-store',\r\n  checkForUpdates = 'check-for-updates',\r\n  toggleDevTools = 'toggle-dev-tools',\r\n  exportStoreData = 'export-store-data',\r\n  importStoreData = 'import-store-data',\r\n  loadStoreData = 'load-store-data',\r\n  setStoreValue = 'set-store-value',\r\n  getStoreValue = 'get-store-value',\r\n}\r\n\r\ntype IpcInvokeReturn<P extends any = any> = {\r\n  success: boolean;\r\n  msg: string;\r\n  payload?: P;\r\n};\r\n\r\n/**\r\n * Typesafety: Expected payload input for ipcChannels\r\n */\r\ntype IpcPayload = {\r\n  [key in IpcChannels]: key extends 'set-store-value'\r\n    ? SetStoreValuePayload\r\n    : any;\r\n};\r\n\r\ninterface I_IpcApi {\r\n  on(channel: string, callback: GenericFunction): void;\r\n  removeListener(channel: string, callback: GenericFunction): void;\r\n  removeAllListeners(channel: string): void;\r\n  send<T extends keyof IpcPayload>(\r\n    channel: T,\r\n    payload?: T extends 'set-store-value' ? SetStoreValuePayload : any,\r\n  ): void;\r\n  invoke<P extends any | any[], T extends keyof IpcPayload = keyof IpcPayload>(\r\n    channel: T,\r\n    payload?: T extends 'set-store-value' ? SetStoreValuePayload : any,\r\n  ): Promise<IpcInvokeReturn<P>>;\r\n}\r\n\r\nexport { IpcChannels };\r\n\r\nexport type { I_IpcApi, IpcPayload, SetStoreValuePayload, IpcInvokeReturn };\r\n","enum ShortcutKeybindingsAliases {\r\n  toggleExample = 'toggleExample',\r\n  toggleWithNotification = 'toggleWithNotification',\r\n  toggleWithByeNotification = 'toggleWithByeNotification',\r\n  toggleDeveloperTools = 'toggleDeveloperTools',\r\n}\r\n\r\nconst DefaultShortcutKeybindings: Record<\r\n  ShortcutKeybindingsAliases,\r\n  { keybind: string; title: string; description?: string }\r\n> = {\r\n  [ShortcutKeybindingsAliases.toggleExample]: {\r\n    keybind: 'Ctrl+Shift+A',\r\n    title: 'Toggle Example',\r\n  },\r\n  [ShortcutKeybindingsAliases.toggleWithNotification]: {\r\n    keybind: 'Ctrl+Shift+S',\r\n    title: 'Toggle With Notification',\r\n  },\r\n  [ShortcutKeybindingsAliases.toggleWithByeNotification]: {\r\n    keybind: 'Ctrl+Shift+D',\r\n    title: 'Toggle With Bye Notification',\r\n  },\r\n  [ShortcutKeybindingsAliases.toggleDeveloperTools]: {\r\n    keybind: 'F12',\r\n    title: 'Toggle Developer Tools',\r\n    description:\r\n      'Shortcut will not work if window is not active/developer tools is active instead',\r\n  },\r\n};\r\n\r\ninterface Shortcut {\r\n  id: ShortcutKeybindingsAliases;\r\n  keybind: string;\r\n  title: string;\r\n  description?: string;\r\n  action: (...args: any[]) => any;\r\n}\r\n\r\ntype ShortcutEventListener = (...args: any[]) => void;\r\n\r\nexport { ShortcutKeybindingsAliases, DefaultShortcutKeybindings };\r\n\r\nexport type { Shortcut, ShortcutEventListener };\r\n","import { IpcMainEvent, IpcMainInvokeEvent } from 'electron';\r\nimport { IpcChannels } from 'shared/types';\r\nimport { IpcInvokeReturn } from 'shared/types/ipc';\r\n\r\nconst getFailChannel = (channel: IpcChannels) => `${channel}-fail`;\r\n\r\nconst getSuccessChannel = (channel: IpcChannels) => `${channel}-success`;\r\n\r\nconst getReplyChannel = (channel: IpcChannels) => `${channel}-reply`;\r\n\r\nconst replySuccess = (\r\n  event: IpcMainEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.reply(getReplyChannel(channel), {\r\n    success: true,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nconst replyFailure = (\r\n  event: IpcMainEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.reply(getReplyChannel(channel), {\r\n    success: false,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nconst replyInvokeSuccess = (\r\n  event: IpcMainInvokeEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.sender.send(getReplyChannel(channel), {\r\n    success: true,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nconst replyInvokeFailure = (\r\n  event: IpcMainInvokeEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.sender.send(getReplyChannel(channel), {\r\n    success: false,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nconst returnIpcInvokeError = (\r\n  error: any,\r\n  msg: string = 'Failed to update store',\r\n): IpcInvokeReturn => {\r\n  let errorStr: string = '';\r\n\r\n  if (typeof error === 'string') {\r\n    errorStr = error;\r\n  } else if (error?.response?.data) {\r\n    errorStr = JSON.stringify(error.response.data);\r\n  } else if (error?.message || error instanceof Error) {\r\n    errorStr = error.message;\r\n  } else {\r\n    errorStr = JSON.stringify(error);\r\n  }\r\n\r\n  return {\r\n    success: false,\r\n    msg,\r\n    ...(errorStr && { payload: errorStr }),\r\n  };\r\n};\r\n\r\nexport {\r\n  getFailChannel,\r\n  getSuccessChannel,\r\n  getReplyChannel,\r\n  replySuccess,\r\n  replyFailure,\r\n  replyInvokeSuccess,\r\n  replyInvokeFailure,\r\n  returnIpcInvokeError,\r\n};\r\n","import { ipcRenderer, IpcRendererEvent } from 'electron';\r\nimport { I_IpcApi, IpcChannels } from 'shared/types';\r\nimport { IpcInvokeReturn, IpcPayload } from 'shared/types/ipc';\r\nimport { getReplyChannel } from '../../shared/utils/ipc';\r\n\r\nconst baseValidChannels: IpcChannels[] = Object.values(IpcChannels);\r\n// [\r\n// IpcChannels.closeApp,\r\n// IpcChannels.restartApp,\r\n// IpcChannels.clearStore,\r\n// IpcChannels.exportStoreData,\r\n// IpcChannels.importStoreData,\r\n// IpcChannels.loadStoreData,\r\n// IpcChannels.setStoreValue,\r\n// IpcChannels.getStoreValue,\r\n// ];\r\n// const failValidChannels = baseValidChannels.map(getFailChannel);\r\n// const successValidChannels = baseValidChannels.map(getSuccessChannel);\r\n// const validChannels = [\r\n//   ...baseValidChannels,\r\n//   ...failValidChannels,\r\n//   ...successValidChannels,\r\n// ];\r\nconst replyValidChannels = baseValidChannels.map(getReplyChannel);\r\nconst validChannels = [...baseValidChannels, ...replyValidChannels];\r\n\r\n/**\r\n * Attaches an event listener to the specified IPC channel.\r\n * @param {string} channel - The IPC channel to listen on.\r\n * @param {function} func - The function to be executed when the event occurs.\r\n */\r\nconst on = (\r\n  channel: string,\r\n  func: (event: IpcRendererEvent, ...args: any[]) => void,\r\n): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.on(channel, (_, ...args) => func(_, ...args));\r\n  }\r\n};\r\n\r\n/**\r\n * Removes an event listener from the specified IPC channel.\r\n * @param {string} channel - The IPC channel to remove the listener from.\r\n * @param {function} func - The function to be removed from the listeners.\r\n */\r\nconst removeListener = (\r\n  channel: string,\r\n  func: (event: IpcRendererEvent, ...args: any[]) => void,\r\n): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.removeListener(channel, (_, ...args) => func(_, ...args));\r\n  }\r\n};\r\n\r\n/**\r\n * Removes all event listeners from the specified IPC channel.\r\n * @param {string} channel - The IPC channel to remove the listener from.\r\n */\r\nconst removeAllListeners = (channel: string): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.removeAllListeners(channel);\r\n  }\r\n};\r\n\r\n/**\r\n * Sends a message to the specified IPC channel.\r\n * @param {string} channel - The IPC channel to send the message to.\r\n * @param {any} payload - The data to be sent with the message.\r\n */\r\nconst send = <P extends any[]>(channel: string, ...payload: P): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.send(channel, ...payload);\r\n  }\r\n};\r\n\r\n/**\r\n * Sends a message to the specified IPC channel and back to renderer\r\n * @param {string} channel - The IPC channel to send the message to.\r\n * @param {any} payload - The data to be sent with the message.\r\n */\r\nconst invoke = <\r\n  P extends any | any[],\r\n  T extends keyof IpcPayload = keyof IpcPayload,\r\n>(\r\n  channel: T,\r\n  payload?: T,\r\n): Promise<IpcInvokeReturn<P>> =>\r\n  new Promise((resolve, reject) => {\r\n    if (validChannels.includes(channel as IpcChannels)) {\r\n      ipcRenderer\r\n        .invoke(channel, payload)\r\n        .then((result: IpcInvokeReturn<P>) => resolve(result))\r\n        .catch((error: unknown) =>\r\n          // ? This will basically never get called due to how the system works\r\n          // ? But ill keep it just in case :P\r\n          reject({ success: false, errorMsg: 'Error', payload: error }),\r\n        );\r\n    } else {\r\n      // Handle the case when the channel is not valid, e.g., throw an error\r\n      reject({\r\n        success: false,\r\n        msg: 'Invalid Channel',\r\n        payload: channel,\r\n      });\r\n    }\r\n  });\r\n\r\nexport const ipcApi: I_IpcApi = {\r\n  on,\r\n  removeListener,\r\n  removeAllListeners,\r\n  send,\r\n  invoke,\r\n};\r\n","import { contextBridge } from 'electron';\r\n\r\nimport { I_ElectronApi } from 'shared/types';\r\nimport { ipcApi } from './bridges/ipc';\r\n\r\nconst electronApi: I_ElectronApi = {\r\n  ipc: ipcApi,\r\n};\r\n\r\ncontextBridge.exposeInMainWorld('electron', electronApi);\r\n"],"names":["root","factory","exports","module","define","amd","a","i","global","__webpack_require__","Symbol","toStringTag","Object","defineProperty","value","require","IpcChannels","ShortcutKeybindingsAliases","toggleExample","toggleWithNotification","toggleWithByeNotification","toggleDeveloperTools","getReplyChannel","channel","baseValidChannels","values","replyValidChannels","map","validChannels","electronApi","ipc","on","func","includes","ipcRenderer","_","args","removeListener","removeAllListeners","send","payload","invoke","Promise","resolve","reject","then","result","catch","error","success","errorMsg","msg","contextBridge","exposeInMainWorld"],"sourceRoot":""}