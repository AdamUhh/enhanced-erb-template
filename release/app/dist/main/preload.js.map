{"version":3,"file":"preload.js","mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,SACb,GAAqB,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,OACP,CACJ,IAAIK,EAAIL,IACR,IAAI,IAAIM,KAAKD,GAAuB,iBAAZJ,QAAuBA,QAAUF,GAAMO,GAAKD,EAAEC,EACvE,CACA,CATD,CASGC,QAAQ,I,mBCRX,IAAIC,EAAsB,CCA1BA,EAAyBP,IACH,oBAAXQ,QAA0BA,OAAOC,aAC1CC,OAAOC,eAAeX,EAASQ,OAAOC,YAAa,CAAEG,MAAO,WAE7DF,OAAOC,eAAeX,EAAS,aAAc,CAAEY,OAAO,GAAO,G,YCL9D,MAAM,EAA+BC,QAAQ,YCQ7C,IAAYC,GAAZ,SAAYA,GACV,uBACA,6BACA,6BACA,2BACA,2BACA,sCACA,oCACA,sCACA,sCACA,kCACA,kCACA,iCACD,CAbD,CAAYA,IAAAA,EAAW,KCLhB,MAAMC,EAAmBC,GAAyB,GAAGA,UCMtDC,EAAmCP,OAAOQ,OAAOJ,GACjDK,EAAqBF,EAAkBG,IAAIL,GAC3CM,EAAgB,IAAIJ,KAAsBE,GCN1CG,EAA6B,CACjCC,IDwF8B,CAC9BC,GA7ES,CACTR,EACAS,KAEIJ,EAAcK,SAASV,IACzB,EAAAW,YAAYH,GAAGR,GAAS,CAACY,KAAMC,IAASJ,EAAKG,KAAMC,I,EAyErDC,eAhEqB,CACrBd,EACAS,KAEIJ,EAAcK,SAASV,IACzB,EAAAW,YAAYG,eAAed,GAAS,CAACY,KAAMC,IAASJ,EAAKG,KAAMC,I,EA4DjEE,mBApD0Bf,IACtBK,EAAcK,SAASV,IACzB,EAAAW,YAAYI,mBAAmBf,E,EAmDjCgB,KA1CW,CAAkBhB,KAAoBiB,KAC7CZ,EAAcK,SAASV,IACzB,EAAAW,YAAYK,KAAKhB,KAAYiB,E,EAyC/BC,OAhCa,CAIblB,EACAiB,IAEA,IAAIE,SAAQ,CAACC,EAASC,KAChBhB,EAAcK,SAASV,GACzB,EAAAW,YACGO,OAAOlB,EAASiB,GAChBK,MAAMC,GAA+BH,EAAQG,KAC7CC,OAAOC,GAGNJ,EAAO,CAAEK,SAAS,EAAOC,SAAU,QAASV,QAASQ,MAIzDJ,EAAO,CACLK,SAAS,EACTE,IAAK,kBACLX,QAASjB,G,aChFjB,EAAA6B,cAAcC,kBAAkB,WAAYxB,G","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///webpack/runtime/make namespace object","webpack:///external node-commonjs \"electron\"","webpack:///./src/shared/types/ipc.ts","webpack:///./src/main/util/ipc.ts","webpack:///./src/main/bridges/ipc.ts","webpack:///./src/main/preload.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"electron\");","import { GenericFunction } from './generic';\r\nimport { CoreElectronStore } from './coreElectronStore';\r\n\r\nexport type SetStoreValuePayload = {\r\n  key: keyof CoreElectronStore;\r\n  state: CoreElectronStore[keyof CoreElectronStore];\r\n};\r\n\r\nexport enum IpcChannels {\r\n  closeApp = 'close-app',\r\n  minimizeApp = 'minimize-app',\r\n  maximizeApp = 'maximize-app',\r\n  restartApp = 'restart-app',\r\n  clearStore = 'clear-store',\r\n  checkForUpdates = 'check-for-updates',\r\n  toggleDevTools = 'toggle-dev-tools',\r\n  exportStoreData = 'export-store-data',\r\n  importStoreData = 'import-store-data',\r\n  loadStoreData = 'load-store-data',\r\n  setStoreValue = 'set-store-value',\r\n  getStoreValue = 'get-store-value',\r\n}\r\n\r\nexport type IpcInvokeReturn<P extends any = any> = {\r\n  success: boolean;\r\n  msg: string;\r\n  payload?: P;\r\n};\r\n\r\n/**\r\n * Typesafety: Expected payload input for ipcChannels\r\n */\r\nexport type IpcPayload = {\r\n  [key in IpcChannels]: key extends 'set-store-value'\r\n    ? SetStoreValuePayload\r\n    : any;\r\n};\r\n\r\nexport interface I_IpcApi {\r\n  on(channel: string, callback: GenericFunction): void;\r\n  removeListener(channel: string, callback: GenericFunction): void;\r\n  removeAllListeners(channel: string): void;\r\n  send<T extends keyof IpcPayload>(\r\n    channel: T,\r\n    payload?: T extends 'set-store-value' ? SetStoreValuePayload : any,\r\n  ): void;\r\n  invoke<P extends any | any[], T extends keyof IpcPayload = keyof IpcPayload>(\r\n    channel: T,\r\n    payload?: T extends 'set-store-value' ? SetStoreValuePayload : any,\r\n  ): Promise<IpcInvokeReturn<P>>;\r\n}\r\n","import { IpcMainEvent, IpcMainInvokeEvent } from 'electron';\r\nimport { IpcChannels, IpcInvokeReturn } from '../../shared/types/ipc';\r\n\r\nexport const getReplyChannel = (channel: IpcChannels) => `${channel}-reply`;\r\n\r\nexport const replySuccess = (\r\n  event: IpcMainEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.reply(getReplyChannel(channel), {\r\n    success: true,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nexport const replyFailure = (\r\n  event: IpcMainEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.reply(getReplyChannel(channel), {\r\n    success: false,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nexport const replyInvokeSuccess = (\r\n  event: IpcMainInvokeEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.sender.send(getReplyChannel(channel), {\r\n    success: true,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nexport const replyInvokeFailure = (\r\n  event: IpcMainInvokeEvent,\r\n  channel: IpcChannels,\r\n  payload?: any,\r\n) => {\r\n  event.sender.send(getReplyChannel(channel), {\r\n    success: false,\r\n    ...(payload && { payload }),\r\n  });\r\n};\r\n\r\nexport const returnIpcInvokeError = (\r\n  error: any,\r\n  msg: string = 'Failed to update store',\r\n): IpcInvokeReturn => {\r\n  let errorStr: string = '';\r\n\r\n  if (typeof error === 'string') {\r\n    errorStr = error;\r\n  } else if (error?.response?.data) {\r\n    errorStr = JSON.stringify(error.response.data);\r\n  } else if (error?.message || error instanceof Error) {\r\n    errorStr = error.message;\r\n  } else {\r\n    errorStr = JSON.stringify(error);\r\n  }\r\n\r\n  return {\r\n    success: false,\r\n    msg,\r\n    ...(errorStr && { payload: errorStr }),\r\n  };\r\n};\r\n","import { ipcRenderer, IpcRendererEvent } from 'electron';\r\nimport {\r\n  I_IpcApi,\r\n  IpcChannels,\r\n  IpcInvokeReturn,\r\n  IpcPayload,\r\n} from '../../shared/types/ipc';\r\nimport { getReplyChannel } from '../util/ipc';\r\n\r\nconst baseValidChannels: IpcChannels[] = Object.values(IpcChannels);\r\nconst replyValidChannels = baseValidChannels.map(getReplyChannel);\r\nconst validChannels = [...baseValidChannels, ...replyValidChannels];\r\n\r\n/**\r\n * Attaches an event listener to the specified IPC channel.\r\n * @param {string} channel - The IPC channel to listen on.\r\n * @param {function} func - The function to be executed when the event occurs.\r\n */\r\nconst on = (\r\n  channel: string,\r\n  func: (event: IpcRendererEvent, ...args: any[]) => void,\r\n): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.on(channel, (_, ...args) => func(_, ...args));\r\n  }\r\n};\r\n\r\n/**\r\n * Removes an event listener from the specified IPC channel.\r\n * @param {string} channel - The IPC channel to remove the listener from.\r\n * @param {function} func - The function to be removed from the listeners.\r\n */\r\nconst removeListener = (\r\n  channel: string,\r\n  func: (event: IpcRendererEvent, ...args: any[]) => void,\r\n): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.removeListener(channel, (_, ...args) => func(_, ...args));\r\n  }\r\n};\r\n\r\n/**\r\n * Removes all event listeners from the specified IPC channel.\r\n * @param {string} channel - The IPC channel to remove the listener from.\r\n */\r\nconst removeAllListeners = (channel: string): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.removeAllListeners(channel);\r\n  }\r\n};\r\n\r\n/**\r\n * Sends a message to the specified IPC channel.\r\n * @param {string} channel - The IPC channel to send the message to.\r\n * @param {any} payload - The data to be sent with the message.\r\n */\r\nconst send = <P extends any[]>(channel: string, ...payload: P): void => {\r\n  if (validChannels.includes(channel as IpcChannels)) {\r\n    ipcRenderer.send(channel, ...payload);\r\n  }\r\n};\r\n\r\n/**\r\n * Sends a message to the specified IPC channel and back to renderer\r\n * @param {string} channel - The IPC channel to send the message to.\r\n * @param {any} payload - The data to be sent with the message.\r\n */\r\nconst invoke = <\r\n  P extends any | any[],\r\n  T extends keyof IpcPayload = keyof IpcPayload,\r\n>(\r\n  channel: T,\r\n  payload?: T,\r\n): Promise<IpcInvokeReturn<P>> =>\r\n  new Promise((resolve, reject) => {\r\n    if (validChannels.includes(channel as IpcChannels)) {\r\n      ipcRenderer\r\n        .invoke(channel, payload)\r\n        .then((result: IpcInvokeReturn<P>) => resolve(result))\r\n        .catch((error: unknown) =>\r\n          // ? This will basically never get called due to how the system works\r\n          // ? But ill keep it just in case :P\r\n          reject({ success: false, errorMsg: 'Error', payload: error }),\r\n        );\r\n    } else {\r\n      // Handle the case when the channel is not valid, e.g., throw an error\r\n      reject({\r\n        success: false,\r\n        msg: 'Invalid Channel',\r\n        payload: channel,\r\n      });\r\n    }\r\n  });\r\n\r\nexport const ipcApi: I_IpcApi = {\r\n  on,\r\n  removeListener,\r\n  removeAllListeners,\r\n  send,\r\n  invoke,\r\n};\r\n","import { contextBridge } from 'electron';\r\n\r\nimport { I_ElectronApi } from 'shared/types/window';\r\nimport { ipcApi } from './bridges/ipc';\r\n\r\nconst electronApi: I_ElectronApi = {\r\n  ipc: ipcApi,\r\n};\r\n\r\ncontextBridge.exposeInMainWorld('electron', electronApi);\r\n"],"names":["root","factory","exports","module","define","amd","a","i","global","__webpack_require__","Symbol","toStringTag","Object","defineProperty","value","require","IpcChannels","getReplyChannel","channel","baseValidChannels","values","replyValidChannels","map","validChannels","electronApi","ipc","on","func","includes","ipcRenderer","_","args","removeListener","removeAllListeners","send","payload","invoke","Promise","resolve","reject","then","result","catch","error","success","errorMsg","msg","contextBridge","exposeInMainWorld"],"sourceRoot":""}