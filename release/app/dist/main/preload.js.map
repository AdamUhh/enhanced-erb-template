{"version":3,"file":"preload.js","mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,SACb,GAAqB,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,OACP,CACJ,IAAIK,EAAIL,IACR,IAAI,IAAIM,KAAKD,GAAuB,iBAAZJ,QAAuBA,QAAUF,GAAMO,GAAKD,EAAEC,EACvE,CACA,CATD,CASGC,QAAQ,I,mBCRX,IAAIC,EAAsB,CCA1BA,EAAyBP,IACH,oBAAXQ,QAA0BA,OAAOC,aAC1CC,OAAOC,eAAeX,EAASQ,OAAOC,YAAa,CAAEG,MAAO,WAE7DF,OAAOC,eAAeX,EAAS,aAAc,CAAEY,OAAO,GAAO,G,YCL9D,MAAM,EAA+BC,QAAQ,YCQ7C,IAAYC,GAAZ,SAAYA,GACV,uBACA,6BACA,6BACA,oCACA,2BACA,2BACA,oCACA,sCACA,mDACA,kCAEA,2DAEA,sCACA,sCACA,kCAEA,kCACA,kCAEA,qDACD,CAtBD,CAAYA,IAAAA,EAAW,KCLhB,MCAMC,EAAmCL,OAAOM,OAAOF,GACjDG,EAAqBF,EAAkBG,KDDpBC,GAAyB,GAAGA,YCE/CC,EAAgB,IAAIL,KAAsBE,GCchD,MAgDMI,EAAuB,CAClCC,EACAC,EAAc,WCrET,IAAsBC,EDwE3B,MAAO,CACLC,SAAS,EACTF,MACAG,SC1EiB,iBADQF,EDuEGF,GCtEME,EAEhCA,GAAKG,UAAUC,KAAaC,KAAKC,UAAUN,EAAIG,SAASC,MAExDJ,GAAKO,QAAgBP,EAAIO,QAEtBF,KAAKC,UAAUN,KDoEC,GACtB,EEvEGQ,EAA6B,CACjCC,ICqF8B,CAC9BC,GApES,CACTf,EACAgB,KAEIf,EAAcgB,SAASjB,IACzB,EAAAkB,YAAYH,GAAGf,GAAS,CAACmB,KAAMC,IAASJ,EAASG,KAAMC,IAAM,EAgE/DC,eAxDqB,CACrBrB,EACAgB,KAEIf,EAAcgB,SAASjB,IACzB,EAAAkB,YAAYG,eAAerB,GAAS,CAACmB,KAAMC,IAASJ,EAASG,KAAMC,IAAM,EAoD3EE,mBA7C0BtB,IACtBC,EAAcgB,SAASjB,IAAU,EAAAkB,YAAYI,mBAAmBtB,EAAQ,EA6C5EuB,KArCW,CACXvB,EACAO,KAEIN,EAAcgB,SAASjB,IAAU,EAAAkB,YAAYK,KAAKvB,EAASO,EAAQ,EAkCvEiB,OA1Ba,IACVJ,IAIH,IAAIK,SAAQ,CAACC,EAASC,KACpB,MAAO3B,EAASO,GAAWa,EACvBnB,EAAcgB,SAASjB,GACzB,EAAAkB,YACGM,OAAOxB,EAASO,GAChBqB,MAAMC,GACLH,EAAQG,KAETC,OAAO3B,GACNwB,EAAOzB,EAAqBC,EAAO,sBAGvCwB,EAAOzB,EAAqBF,EAAS,mB,aD9E3C,EAAA+B,cAAcC,kBAAkB,WAAYnB,G","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///webpack/runtime/make namespace object","webpack:///external node-commonjs \"electron\"","webpack:///./src/shared/types/ipc.ts","webpack:///./src/shared/utils/getReplyChannel.ts","webpack:///./src/shared/utils/channels.ts","webpack:///./src/main/listeners/util/ipcReplies.ts","webpack:///./src/shared/utils/stringifyObj.ts","webpack:///./src/main/preload.ts","webpack:///./src/main/bridges/ipcRenderer.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"electron\");","import { CoreElectronStore } from './coreElectronStore';\nimport { GenericFunction } from './generic';\n\nexport type SetStoreValuePayload = {\n  key: keyof CoreElectronStore;\n  state: CoreElectronStore[keyof CoreElectronStore];\n};\n\nexport enum IpcChannels {\n  closeApp = 'close-app',\n  minimizeApp = 'minimize-app',\n  maximizeApp = 'maximize-app',\n  isAppMaximized = 'is-app-maximized',\n  restartApp = 'restart-app',\n  clearStore = 'clear-store',\n  toggleDevTools = 'toggle-dev-tools',\n  checkForUpdates = 'check-for-updates',\n  quitAndInstallUpdates = 'quit-and-install-updates',\n  appUpdateInfo = 'app-update-info',\n\n  toggleRendererErrorDialog = 'toggle-renderer-error-dialog',\n\n  exportStoreData = 'export-store-data',\n  importStoreData = 'import-store-data',\n  loadStoreData = 'load-store-data',\n\n  setStoreValue = 'set-store-value',\n  getStoreValue = 'get-store-value',\n\n  toggleExampleVisibility = 'toggle-example-visibility',\n}\n\n/** Typesafe: Expected payload INPUT for ipcChannels */\nexport type IpcPayloadInputLookup = {\n  [IpcChannels.setStoreValue]: SetStoreValuePayload;\n  [IpcChannels.getStoreValue]: keyof CoreElectronStore;\n  [IpcChannels.toggleExampleVisibility]: boolean | undefined;\n};\n\n/** Typesafe: Expected payload RETURN for ipcChannels */\nexport type IpcPayloadOutputLookup = {\n  [IpcChannels.isAppMaximized]: boolean;\n  [IpcChannels.getStoreValue]: CoreElectronStore[keyof CoreElectronStore];\n  [IpcChannels.toggleExampleVisibility]: boolean;\n};\n\n/** Typesafe: Special expected payload RETURN, specifically for ipcMain.handle ipcChannels\n *\n * This overrides return from IpcExpectedReturnLookup\n */\nexport type IpcMainPayloadOutputLookup = {\n  [IpcChannels.setStoreValue]: CoreElectronStore[keyof CoreElectronStore];\n};\n\nexport type IpcReturnFormat<P = any> = {\n  success: boolean;\n  msg?: string;\n  description?: string;\n  payload?: P;\n};\n\nexport type IpcErrorReturnFormat<P = any> = {\n  success: false;\n  msg: string;\n  description?: string;\n  payload?: P;\n};\n\nexport type IpcSendPayloadOutput<\n  T extends IpcChannels,\n  P = undefined,\n> = T extends keyof IpcPayloadOutputLookup ? IpcPayloadOutputLookup[T] : P;\n\nexport type IpcMainPayloadOutput<\n  T extends IpcChannels,\n  P = undefined,\n> = T extends keyof IpcMainPayloadOutputLookup\n  ? IpcMainPayloadOutputLookup[T]\n  : P;\n\nexport type IpcPayloadOutput<\n  T extends IpcChannels,\n  P = undefined,\n> = T extends keyof IpcMainPayloadOutputLookup\n  ? IpcMainPayloadOutputLookup[T]\n  : IpcSendPayloadOutput<T, P>;\n\nexport type IpcInvokeReturn<T extends IpcChannels> =\n  | IpcReturnFormat<IpcPayloadOutput<T>>\n  | IpcErrorReturnFormat;\n\nexport type IpcReturn<T extends IpcChannels> = IpcReturnFormat<\n  IpcPayloadOutput<T>\n>;\n\nexport type IpcSendReturn<T extends IpcChannels> = IpcReturnFormat<\n  IpcSendPayloadOutput<T>\n>;\n\nexport type IpcExpectedInput<T extends IpcChannels> =\n  T extends keyof IpcPayloadInputLookup ? IpcPayloadInputLookup[T] : undefined;\n\nexport interface I_IpcApi {\n  /**\n   * Attaches an event listener to the specified IPC channel.\n   * @param {string} channel - The IPC channel to listen on.\n   * @param {function} func - The function to be executed when the event occurs.\n   */\n  on(channel: string, callback: GenericFunction): void;\n  /**\n   * Removes an event listener from the specified IPC channel.\n   * @param {string} channel - The IPC channel to remove the listener from.\n   * @param {function} func - The function to be removed from the listeners.\n   */\n  removeListener(channel: string, callback: GenericFunction): void;\n  /**\n   * Removes all event listeners from the specified IPC channel.\n   * @param {string} channel - The IPC channel to remove the listener from.\n   */\n  removeAllListeners(channel: string): void;\n  /**\n   * Sends a message to the specified IPC channel.\n   * @param {string} channel - The IPC channel to send the message to.\n   * @param {any} payload - The data to be sent with the message.\n   */\n  send<T extends IpcChannels>(\n    ...args: T extends keyof IpcPayloadInputLookup\n      ? [channel: T, payload: IpcExpectedInput<T>]\n      : [channel: T]\n  ): void;\n  /**\n   * Sends a message to the specified IPC channel and back to renderer\n   * @param {string} channel - The IPC channel to send the message to.\n   * @param {any} payload - The data to be sent with the message.\n   */\n  invoke<T extends IpcChannels>(\n    ...args: T extends keyof IpcPayloadInputLookup\n      ? [channel: T, payload: IpcExpectedInput<T>]\n      : [channel: T]\n  ): Promise<IpcInvokeReturn<T>>;\n}\n","import { IpcChannels } from 'shared/types/ipc';\n\n/** Converts base channels to a `*-reply` channel */\nexport const getReplyChannel = (channel: IpcChannels) => `${channel}-reply`;\n","import { IpcChannels } from '../types/ipc';\nimport { getReplyChannel } from './getReplyChannel';\n\nexport const baseValidChannels: IpcChannels[] = Object.values(IpcChannels);\nexport const replyValidChannels = baseValidChannels.map(getReplyChannel);\nexport const validChannels = [...baseValidChannels, ...replyValidChannels];\n","import { IpcMainEvent } from 'electron';\nimport {\n  IpcChannels,\n  IpcInvokeErrorReturn,\n  IpcInvokeReturn,\n} from '../../../shared/types/ipc';\nimport { getReplyChannel } from '../../../shared/utils/getReplyChannel';\nimport { stringifyObj } from '../../../shared/utils/stringifyObj';\n\n/** Sends a success object to the same renderer frame that sent the original request\n *\n * Requires a `*-reply` channel that is listening\n *\n * Provided channel is automatically converted into a `*-reply` channel\n *\n * Used in ipcMain.on() listeners\n *\n * Useful if you want some component to run code after a success for a specific channel\n */\nexport const replySuccess = (\n  event: IpcMainEvent,\n  channel: IpcChannels,\n  payload?: { msg?: string; payload?: any },\n) => {\n  event.reply(getReplyChannel(channel), {\n    success: true,\n    msg: payload?.msg ?? '',\n    payload: payload?.payload ?? undefined,\n  } as IpcInvokeReturn);\n};\n\n/** Sends a failure object to the same renderer frame that sent the original request\n *\n * Requires a `*-reply` channel that is listening,\n *\n * Provided channel is automatically converted into a `*-reply` channel\n *\n * Used in ipcMain.on() listeners\n *\n * Useful if you want some component to run code after a failure for a specific channel\n *\n */\nexport const replyFailure = (\n  event: IpcMainEvent,\n  channel: IpcChannels,\n  payload?: { msg?: string; payload?: any },\n) => {\n  console.log(\n    `Oops, there was an error on channel: ${channel}${\n      payload?.msg && `\\n->Message:\\n${payload.msg}`\n    } ${payload?.payload && `\\n-> Payload:\\n ${payload.payload}`}\\n`,\n  );\n  event.reply(getReplyChannel(channel), {\n    success: false,\n    msg: payload?.msg ?? '',\n    payload: payload?.payload ?? undefined,\n  } as IpcInvokeErrorReturn);\n};\n\n/** Returns a failure object to the ipc that called the invoke\n *\n * Suited for ipcMain.handle() listeners\n *\n * @param error Stringified Error object (most likely from catch statement)\n * @param msg Custom error message\n * @returns Standard invoke return object; {success: boolean, msg: string, payload: string}\n */\nexport const returnIpcInvokeError = (\n  error: any,\n  msg: string = 'Error',\n): IpcInvokeErrorReturn => {\n  const errorStr = stringifyObj(error);\n  return {\n    success: false,\n    msg,\n    payload: errorStr ?? '',\n  };\n};\n","export function stringifyObj(obj: any): string {\n  if (typeof obj === 'string') return obj;\n\n  if (obj?.response?.data) return JSON.stringify(obj.response.data);\n\n  if (obj?.message) return obj.message;\n\n  return JSON.stringify(obj);\n}\n","import { contextBridge } from 'electron';\n\nimport { ipcApi } from './bridges/ipcRenderer';\nimport { I_ElectronApi } from '../shared/types/window';\n\nconst electronApi: I_ElectronApi = {\n  ipc: ipcApi,\n};\n\ncontextBridge.exposeInMainWorld('electron', electronApi);\n","/**\n *\n * This file contains the typesafe ipcRenderer logic that is used on client/renderer side to be sent to main\n *\n */\n\nimport { ipcRenderer, IpcRendererEvent } from 'electron';\nimport {\n  I_IpcApi,\n  IpcChannels,\n  IpcPayloadInputLookup,\n  IpcExpectedPayloadReturn,\n  IpcInputConditional,\n  IpcInvokeReturn,\n  IpcReturn,\n} from '../../shared/types/ipc';\nimport { validChannels } from '../../shared/utils/channels';\nimport { returnIpcInvokeError } from '../listeners/util/ipcReplies';\n\n/**\n * Attaches an event listener to the specified IPC channel.\n * @param channel - The IPC channel to listen on.\n * @param callback - The function to be executed when the event occurs.\n */\nconst on = (\n  channel: IpcChannels,\n  callback: (event: IpcRendererEvent, ...args: any[]) => void,\n): void => {\n  if (validChannels.includes(channel))\n    ipcRenderer.on(channel, (_, ...args) => callback(_, ...args));\n};\n\n/**\n * Removes an event listener from the specified IPC channel.\n * @param channel - The IPC channel to remove the listener from.\n * @param callback - The function to be removed from the listeners.\n */\nconst removeListener = (\n  channel: IpcChannels,\n  callback: (event: IpcRendererEvent, ...args: any[]) => void,\n): void => {\n  if (validChannels.includes(channel))\n    ipcRenderer.removeListener(channel, (_, ...args) => callback(_, ...args));\n};\n\n/**\n * Removes all event listeners from the specified IPC channel.\n * @param channel - The IPC channel to remove the listener from.\n */\nconst removeAllListeners = (channel: IpcChannels): void => {\n  if (validChannels.includes(channel)) ipcRenderer.removeAllListeners(channel);\n};\n\n/**\n * Typesafe IPC method that sends a `send` message to the specified IPC channel.\n * @param channel - The IPC channel to send the message to.\n * @param payload - The data to be sent with the message.\n */\nconst send = <T extends IpcChannels>(\n  channel: T,\n  payload?: IpcInputConditional<T>,\n): void => {\n  if (validChannels.includes(channel)) ipcRenderer.send(channel, payload);\n};\n\n/**\n * Typesafe IPC method that sends an `invoke` message to the specified IPC channel and returns a response back (to the renderer)\n * @param channel - The IPC channel to send the message to.\n * @param payload - The data to be sent with the message.\n */\nconst invoke = <T extends IpcChannels>(\n  ...args: T extends keyof IpcPayloadInputLookup\n    ? [channel: T, payload?: IpcInputConditional<T>]\n    : [channel: T]\n): Promise<IpcReturn<T>> =>\n  new Promise((resolve, reject) => {\n    const [channel, payload] = args;\n    if (validChannels.includes(channel)) {\n      ipcRenderer\n        .invoke(channel, payload)\n        .then((result: IpcInvokeReturn<IpcExpectedPayloadReturn<T>>) =>\n          resolve(result),\n        )\n        .catch((error: unknown) =>\n          reject(returnIpcInvokeError(error, 'Error in invoke')),\n        );\n    } else {\n      reject(returnIpcInvokeError(channel, 'Invalid Channel'));\n    }\n  });\n\nexport const ipcApi: I_IpcApi = {\n  on,\n  removeListener,\n  removeAllListeners,\n  send,\n  invoke,\n};\n"],"names":["root","factory","exports","module","define","amd","a","i","global","__webpack_require__","Symbol","toStringTag","Object","defineProperty","value","require","IpcChannels","baseValidChannels","values","replyValidChannels","map","channel","validChannels","returnIpcInvokeError","error","msg","obj","success","payload","response","data","JSON","stringify","message","electronApi","ipc","on","callback","includes","ipcRenderer","_","args","removeListener","removeAllListeners","send","invoke","Promise","resolve","reject","then","result","catch","contextBridge","exposeInMainWorld"],"sourceRoot":""}